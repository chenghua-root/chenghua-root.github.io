---  
layout: post  
title:  "事务原理与实现机制"  
date:   2019-08-20 21:03:36 +0530  
---  
  
## 什么是事务  
  事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。    
  事务需作为一个原子被孤立地执行。    
  任何一个查询或修改动作本身就可以是一个事务。    
  
## 为什么需要事务  
  举例1：    
    A给B转账100元，若在A扣除100元后系统宕机。则存在：A减掉了100元，B却未加上100元。    
    可以把这个转账操作称为一个事务，则这个事务需要全部完成，或者全部不完成。    
    即事务需要被原子执行。    
  
  举例2：    
    A和B同时给C转账100元。C可能增加了100元，也可能增加200元。（比如，C账户数据在磁盘上，需要读取上来增加100后再写回）    
    事务需要被孤立的执行，即事务执行期间互相不影响。至少是“看上去”像只有本事务在执行。    
  
## 事务特性  
  为了解决以上例子面临的问题，对事务规定了如下要求：    
  * 原子性：事务包含一个或多个步骤，必须作为一个整体执行或根本不执行。不能只执行部分。    
  * 一致性：事务应确保数据库的状态从一个一致状态转变为另外一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。    
  * 隔离性：并发事务。数据库允许多个事务并发执行，隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致。    
  * 持久性：已被提交的事务对数据库的修改应该永久保存在数据库中。    
  
ACID关系：    
  - **在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。**    
    所谓一致性，指的是数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。    
  
  - 在数据库实现的场景中，一致性可以分为数据库外部的一致性和数据库内部的一致性。前者由外部应用的编码来保证，即某个应用在执行转帐的数据库操作时，必须在同一个事务内部调用对帐户A和帐户B的操作。如果在这个层次出现错误，这不是数据库本身能够解决的，也不属于我们需要讨论的范围。后者由数据库来保证，即在同一个事务内部的一组操作必须全部执行成功（或者全部失败）。这就是事务处理的原子性。    
    为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。    
  
  - 但是，原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上， 事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。    
    为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。    
  
## 原子性  
### 如何保证原子性  
  事务在执行过程中，可能因为服务程序退出、系统故障等导致事务只执行了部分，从而不满足原子性。    
  如何保证事务必须原子的执行，即全做或全不做，并且在时间上看上去似乎是在某个时刻瞬间完成的。    
  保证事务正确执行是事务管理器的工作，事务管理子系统完成的功能包括：    
  - 使用日志保证原子性：给日志管理器发信号，使必须的信息以日志记录的形式存储在日志中。    
  - 通过并发控制来保证隔离性：保证并发执行的事务不会以引入错误的方式相互干扰（见后面并发控制）    
  本节主要讨论日志来保证原子性。    
  
### 事务的原语操作  
  事务需要原子的执行，但事务本身是包含一个或多个操作的，每个操作被定义为一个原语。下面详细列出事务是如何同数据库交互的。    
  1. 保存数据库元素的磁盘块空间。    
  2. 缓冲区管理器所管理的主存地址空间。    
  3. 事务的局部地址空间。    
  
  事务要读取数据库元素，该元素必须先读取到主存的一个或多个缓冲区中。接下来，缓冲区的内容可以被事务读到其局部地址空间中。事务为数据库元素写入一个新值的过程相反。    
  
  缓冲区中的内容可能是也可能不是被立即拷贝到磁盘。基于可恢复性和性能方面，会选择适当的时机把缓冲区数据更新到磁盘。    
  
  后面讨论使用的原语包括：    
  * INPUT(X)：将包含数据库元素X的磁盘块拷贝到主存缓冲区    
  * READ(X, t)：将数据库元素X拷贝到事务局部变量t。若X不在缓冲区中，则首先执行INPUT(X)    
  * WRITE(X, t)：将局部变量t的值拷贝到主存缓冲区中的数据库元素X    
  * OUTPUT(X)：将包含X的缓冲区中的块拷贝回磁盘    
  
  问题：    
  工程实现中是否一定需要缓冲区？    
  
#### 原语操作与事务操作的联系：  
  举例，事务T逻辑上由下述两步构成：    
  * A := A * 2    
  * B := B * 2    
  一致性约束：事务执行前A = B，事务完成后A仍然等于B。    
  
  | 动作       |   t   | 内存中的A | 内存中的B | 磁盘中的A | 磁盘中的B |  
  | -----      | ----  |    -----  |    -----  |    -----  |    -----  |  
  | READ(A,t)  | 8     | 8         |           |  8        | 8         |  
{: .tablelines}  
  
  如果所有的这些步骤都执行，数据库的一致性就能得到保证。如果在执行OUTPUT(A)之前发生了系统故障，磁盘上存储的数据不会受到影响，一致性不会受到影响。    
  
<style>  
.tablelines table, .tablelines td, .tablelines th {  
        border: 1px solid black;  
        }  
</style>  
  
| Header Cell | Header Cell | Header Cell | Header Cell | Header Cell | Header Cell |  
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |  
| Content Cell | Content Cell | Content Cell | Content Cell | Content Cell | Content Cell |  
{: .tablelines}  
  
  **如果系统故障在OUTPUT(A)之后OUTPUT(B)之前发生，则数据一致性被破坏。**    
  
## 日志  
前面提到，我们可以通过日志来保证事务的原子性。如何利用日志来保证原子性？  
我们可以对每个可能改变一致性的操作进行日志记录，根据日志来进行恢复。  
根据不同的日志类型可以采取不同的恢复策略，这里主要列举UNDO和REDO日志：  
- UNDO日志：记录操作前的数据状态，当事务被中断执行后，我们根据日志恢复到执行前的状态。  
- REDO日志：记录事务完成后数据应该有的状态。当事务被中断执行后，根据REDO日志继续执行。  
  
**日志记录：**  
可以将日志看作一个只能查看或追加写的文件。当事务执行时，日志管理器负责在日志中记录每个重要的事件。日志记录形式：  
- <START T>: 这一记录表示事务T已开设  
- <COMMIT T>: 事务T已经成功完成并且对数据库元素不再会修改。事务T对数据库所做的任何更新都应记录到磁盘上。  
- <ABORT T>: 事务T不能成功完成。如果事务T中止，它所做的更新都不应该反映在磁盘上，若已经修改磁盘，则需要消除更新。  
  
### UNDO日志：  
除了上面的日志记录，UNDO日志还有自己的更新日志记录。  
更新日志记录<T, X, v>：事务T改变了数据库元素X，而X原来的值是v。更新记录所反映的改变通常发生在主存中而不是磁盘上：即日志记录是对写入内存的WRITE动作做出的反应，而不是写入磁盘OUTPUT动作所做的反应。  
  
问题:  
日志记录与WRITE()和OUTPUT()的关系  
  
**undo日志规则：**  
- U1：如果事务T改变了数据库元素X，那么形如<T, X, v>的日志记录必须在X的新值写到磁盘之前写到磁盘中。  
- U2：如果事务提交，则其COMMIT日志记录必须在事务改变的所有数据库元素先写到磁盘之后写到磁盘。  
  
日志与执行语句的顺序关系：  
