---    
layout: post    
title:  "事务原理与实现机制"    
date:   2019-08-20 21:03:36 +0530    
---    
    
## 什么是事务    
  事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。      
  事务需作为一个原子被孤立地执行。      
  任何一个查询或修改动作本身就可以是一个事务。      
    
## 为什么需要事务    
  举例1：      
    A给B转账100元，若在A扣除100元后系统宕机。则存在：A减掉了100元，B却未加上100元。      
    可以把这个转账操作称为一个事务，则这个事务需要全部完成，或者全部不完成。      
    即事务需要被原子执行。      
    
  举例2：      
    A和B同时给C转账100元。C可能增加了100元，也可能增加200元。（比如，C账户数据在磁盘上，需要读取上来增加100后再写回）      
    事务需要被孤立的执行，即事务执行期间互相不影响。至少是“看上去”像只有本事务在执行。      
    
## 事务特性    
  为了解决以上例子面临的问题，对事务规定了如下要求：      
  * 原子性：事务包含一个或多个步骤，必须作为一个整体执行或根本不执行。不能只执行部分。      
  * 一致性：事务应确保数据库的状态从一个一致状态转变为另外一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。      
  * 隔离性：并发事务。数据库允许多个事务并发执行，隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致。      
  * 持久性：已被提交的事务对数据库的修改应该永久保存在数据库中。      
    
ACID关系：      
  - **在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。**      
    所谓一致性，指的是数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。      
    
  - 在数据库实现的场景中，一致性可以分为数据库外部的一致性和数据库内部的一致性。前者由外部应用的编码来保证，即某个应用在执行转帐的数据库操作时，必须在同一个事务内部调用对帐户A和帐户B的操作。如果在这个层次出现错误，这不是数据库本身能够解决的，也不属于我们需要讨论的范围。后者由数据库来保证，即在同一个事务内部的一组操作必须全部执行成功（或者全部失败）。这就是事务处理的原子性。      
    为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。      
    
  - 但是，原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上， 事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。      
    为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。      
    
## 原子性    
### 如何保证原子性    
  事务在执行过程中，可能因为服务程序退出、系统故障等导致事务只执行了部分，从而不满足原子性。      
  如何保证事务必须原子的执行，即全做或全不做，并且在时间上看上去似乎是在某个时刻瞬间完成的。      
  保证事务正确执行是事务管理器的工作，事务管理子系统完成的功能包括：      
  - 使用日志保证原子性：给日志管理器发信号，使必须的信息以日志记录的形式存储在日志中。      
  - 通过并发控制来保证隔离性：保证并发执行的事务不会以引入错误的方式相互干扰（见后面并发控制）      
  本节主要讨论日志来保证原子性。      
    
### 事务的原语操作    
  事务需要原子的执行，但事务本身是包含一个或多个操作的，每个操作被定义为一个原语。下面详细列出事务是如何同数据库交互的。      
  1. 保存数据库元素的磁盘块空间。      
  2. 缓冲区管理器所管理的主存地址空间。      
  3. 事务的局部地址空间。      
    
  事务要读取数据库元素，该元素必须先读取到主存的一个或多个缓冲区中。接下来，缓冲区的内容可以被事务读到其局部地址空间中。事务为数据库元素写入一个新值的过程相反。      
    
  缓冲区中的内容可能是也可能不是被立即拷贝到磁盘。基于可恢复性和性能方面，会选择适当的时机把缓冲区数据更新到磁盘。      
    
  后面讨论使用的原语包括：      
  * INPUT(X)：将包含数据库元素X的磁盘块拷贝到主存缓冲区      
  * READ(X, t)：将数据库元素X拷贝到事务局部变量t。若X不在缓冲区中，则首先执行INPUT(X)      
  * WRITE(X, t)：将局部变量t的值拷贝到主存缓冲区中的数据库元素X      
  * OUTPUT(X)：将包含X的缓冲区中的块拷贝回磁盘      
    
  问题：      
  工程实现中是否一定需要缓冲区？      
    
#### 原语操作与事务操作的联系：    
  举例，事务T逻辑上由下述两步构成：      
  * A := A * 2      
  * B := B * 2      
  一致性约束：事务执行前A = B，事务完成后A仍然等于B。      
    
  | 动作       |   t   | 内存中的A | 内存中的B | 磁盘中的A | 磁盘中的B |    
  | -----      | ----  |    -----  |    -----  |    -----  |    -----  |    
  | READ(A,t)  | 8     | 8         |           |  8        | 8         |    
{: .tablelines}    
    
  如果所有的这些步骤都执行，数据库的一致性就能得到保证。如果在执行OUTPUT(A)之前发生了系统故障，磁盘上存储的数据不会受到影响，一致性不会受到影响。      
    
<style>    
.tablelines table, .tablelines td, .tablelines th {    
        border: 1px solid black;    
        }    
</style>    
    
| Header Cell | Header Cell | Header Cell | Header Cell | Header Cell | Header Cell |    
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |    
| Content Cell | Content Cell | Content Cell | Content Cell | Content Cell | Content Cell |    
{: .tablelines}    
    
  **如果系统故障在OUTPUT(A)之后OUTPUT(B)之前发生，则数据一致性被破坏。**      
    
## 日志    
前面提到，我们可以通过日志来保证事务的原子性。如何利用日志来保证原子性？    
我们可以对每个可能改变一致性的操作进行日志记录，根据日志来进行恢复。    
根据不同的日志类型可以采取不同的恢复策略，这里主要列举UNDO和REDO日志：    
- UNDO日志：记录操作前的数据状态，当事务被中断执行后，我们根据日志恢复到执行前的状态。    
- REDO日志：记录事务完成后数据应该有的状态。当事务被中断执行后，根据REDO日志继续执行。    
    
**日志记录：**    
可以将日志看作一个只能查看或追加写的文件。当事务执行时，日志管理器负责在日志中记录每个重要的事件。日志记录形式：    
- <START T>: 这一记录表示事务T已开设    
- <COMMIT T>: 事务T已经成功完成并且对数据库元素不再会修改。事务T对数据库所做的任何更新都应记录到磁盘上。    
- <ABORT T>: 事务T不能成功完成。如果事务T中止，它所做的更新都不应该反映在磁盘上，若已经修改磁盘，则需要消除更新。    
    
### UNDO日志：    
除了上面的日志记录，UNDO日志还有自己的更新日志记录。    
更新日志记录<T, X, v>：事务T改变了数据库元素X，而X原来的值是v。更新记录所反映的改变通常发生在主存中而不是磁盘上：即日志记录是对写入内存的WRITE动作做出的反应，而不是写入磁盘OUTPUT动作所做的反应。    
    
问题:    
日志记录与WRITE()和OUTPUT()的关系    
    
**undo日志规则：**    
- U1：如果事务T改变了数据库元素X，那么形如<T, X, v>的日志记录必须在X的新值写到磁盘之前写到磁盘中。    
- U2：如果事务提交，则其COMMIT日志记录必须在事务改变的所有数据库元素先写到磁盘之后写到磁盘。    
    
日志与执行语句的顺序关系：    
**表格**  
  
**使用undo日志进行恢复：**  
- 区分已提交事务和未提交事务  
 - 从上面的阐述可知，往前回溯日志，只要有<COMMIT T>日志记录，则表明事务T已经提交。  
 - 若在回溯的过程中发现了<START T>，但未有对应的<COMMIT T>记录，那么事务T未完成提交，其修改的数据存在一部分数据写入磁盘，另外一部分未写入的可能。  
 - 根据undo日志规则，需要撤销整个事务，即数据恢复到事务开始之前的状态。  
  
- 恢复方法  
1. 由于可能有多个未提交的事务，甚至多个未提交事务修改了同一个元素，所以恢复顺序必须是有顺序的：从尾部（最新日志）开始扫描日志  
2. 如果T的COMMIT记录被扫描到，则什么也不做。  
3. 否则，T是一个未完成的事务，或一个中止事务。必须撤销修改的数据。对完成恢复的事务，记录日志<ABORT T>，表明事务已经被恢复过。  
  
**检查点：**  
上面的恢复方法需要回溯整个日志记录。避免方法是加入检查点，即检查点之前的日志已经全部完成提交。  
如何添加检查点：  
1. 停止接收新的事务  
2. 等到所有的当前活跃事务提交或中止并且在日志中写入COMMIT或ABORT记录  
3. 将日志刷新到磁盘  
4. 写入日志记录<CKPT>，并再次刷新日志  
5. 重新开始接收  
  
**非静止检查点：**  
上面的检查点为静止检查点，需要暂停新事务的执行，于是引入了非静止检查点。  
非静止检查点的思想为记录检查点日志<START CKPT(T1, ..., Tn)>，等待(T1, ..., Tn)都完成后记录<END CKPT(T1, ..., Tn)>。后续只需回溯到<START CKPT>或<START CKPT> + (T1, .., Tn)事务。  
  
**REDO日志：**  
除了undo日志，还可以通过redo日志或undo+redo日志来保证事务原子性，暂略。  
  
## 持久性：  
持久性主要包括两点：  
1. 事务角度：提交的事务写回磁盘，或者宕机后能通过日志恢复  
2. 存储角度：保证写入的数据的可靠性。如：磁盘阵列，主备同步，多副本（raft/paxos）  
  
## 隔离性：  
**隔离性是指事务并发执行时可能互相影响，根据不同的影响程度进行不同隔离级别的定义。**  
**如果事务是串行执行的，则在保证原子性和持久性的基础上就满足了事务的一致性。**后续的讨论将不再必要。  
但是，为了提高系统的事务处理能力，系统会并发的执行事务。在并发执行过程中，存在影响数据一致性的行为。  
不一致的表现总结如下：  
- 丢失更新：  
  - A和B同时给C转账100元。最后C只增加了100元。  
- 脏读：读取到未提交的数据  
  - A转账100元给账号B，在转账的同时计算A和B的余额之和。  
**表格**  
- 不可重复读：同一个事务两次读取同一行记录，返回的值不一致  
**表格**  
- 幻读  
**表格**  
  
### 隔离级别：  
根据如上几种不一致的表现定义了如下几种隔离级别：  
**表格**  
读已提交是所有OLTP数据库系统（MySQL, Oracle, OceanBase, ）最低的隔离级别。  
不同数据库系统支持的隔离级别：  
- MySQL：RC、RR  
- OceanBase/Blade：RC  
- TiDB：RR  
为了使事务在并发执行过程中避免不一致的行为，即满足一定的隔离级别，需要对事务执行进行调度，即并发控制。  
更详细的隔离级别分享参考数据库事务隔离标准分析  
  
## 并发控制：  
什么是并发控制？  
- 不同事务各个步骤的执行顺序必须以某种方式进行规范，该规范由调度器部件完成，保证并发执行的事务能保持一致性的整个过程称为并发控制。  
串行调度：  
- 即为事务一个一个的执行。  
可串行化调度：  
- 对于每个数据库初态，若调度S和串行调度S'的效果一致，则S是可串行化的。  
冲突可串行化调度：  
- 如果通过一系列相邻动作的非冲突交换能将它们中的一个转换为另外一个，我们说两个调度是冲突等价的。  
- **如果一个调度冲突等价于一个串行调度，那么我们说该调度是冲突可串行化的。**  
- 冲突：  
  - 不同事务的操作设计同一数据库元素  
  - 至少有一个是写操作  
- 举例：  
  - 调度：r1(A); w1(A); r2(A); w2(A); r1(B); w1(B); r2(B); w2(B);  
  - 可调整为：r1(A); w1(A); r1(B); w1(B); r2(A); w2(A); r2(B); w2(B);  
  
### 使用锁的并发控制：  
在探索使用锁来实现可串行化之前，先列出所有的锁。  
锁的分类：  
 - 属性锁：共享锁（读锁）、排他锁（写锁）、更新锁、增量锁;  
 - 锁范围：行锁、表锁、页锁、间隙锁  
 - 状态锁：意向锁  
 - 锁模型：两阶段锁  
  
**锁：**  
在操作对应的数据前，先申请锁，申请成功后再执行。  
锁能解决的问题：  
 - 加写锁：更新的时候加锁。解决丢失更新的问题，但不能解决读未提交的数据。  
 - 写锁+提交位：写的时候加锁，读的时候根据提交位避免读取未提交的数据，缓存中保存了未提交的数据和之前已经提交的数据。解决读未提交的数据，但不能解决无法重复读的问题。  
 - 读锁+写锁：读的时候加读锁，写的时候加写锁。解决了不能重复读的问题，但不能解决幻读的问题。  
 - 读锁+写锁+间隙锁：解决了幻读的问题。  
  
问题：  
- 为什么加读写锁后能保证一致性？(参考两阶段锁的证明。)  
  
**两阶段锁：**  
- **即使在有锁的情况下仍然不能保证调度是可串行化的。**  
先定义锁原语：  
- L1(X)：事务1对元素X申请锁  
- U1(X)：事务1对元素X释放锁  
举例：  
初始值A=25, B=25。事务T1: A+100, B+100，事务T2：A=A*2, B=B*2。一致性约束: A = B  
  
